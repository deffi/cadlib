Next:
  * Use scale_uniform in scale() generator
  * ScaleXyz should not accept a vector, similar to RotateXyz and RotateYpr
  * Tests: pass empty or wrong-size vectors, must fail (all transforms, cube,
    others?)

Library:
  * [Medium] from cadlib import * short import all shortcuts, and only those

Geometry:
  * [Medium] Vector: static is_valid (to replace isinstance (Vector, list, tuple))
  * [Low]    Matrix: Add @classmethods .from_rows (forwards to constructor) and .from_columns (accept list-of-list and vectors)
  * [Low]    Allow creating square matrices from a simple list of values

Object:
  * [Medium] At least call the "ridiculous" transforms, and add manual tests
             That's Plane, Slice, and ScaleAxisFactor
  * [Medium] Assembly objects
             Idea: Assembly is an Object; Object has a render() that returns an object or a CSG; primitives' render()
             returns self
  * [Medium] larger, smaller
             Since we can't enlarge an assembly without rendering it first, we may need to defer enlarging to
             render-time by adding an Enlarge class.
  * [Medium] Anchors
             Idea:
                 wheel = Wheel(2).center.at(car.front_left_wheel)
  * [Medium] center flag (and use in examples where appropriate)
             Probably better: .center() which transforms to the center
             Probably even better: use the anchor mechanism
  * [Medium] Do we want Cube(x, y, z) instead of Cube([x, y, z])? rotate_xyz
             does it like this and the argument is not (strictly) a vector
  * [Low]    Shape (2-dimensional object) and associated primitives
  * [Low]    Investigate part/hole
               * Are we supposed to do Pipe+Hole or Pipe-Hole?
               * Can we do Block - (Pipe +- Hole)?
               * Is Hole * Object defined?
  * [Medium] Can we do [cube, sphere, cylinder].sum()?
  * [Medium] Primitives' __repr__ is not a repr

Primitives:
  * [Medium] More primitives: cone
  * [Medium] Plane: through point

CSG:
  * [Medium] Union/... aus Iterable erstellen (Union(o for o in objects))

Transform:
  * [High]   Update scale generator to use ScaleUniform
  * [High]   ScaleXyz should not accept a vector, similar to RotateXyz and
             RotateYpr
  * [Medium] Scale around (instead of along) axis?
             Maybe: scale(axis, along, around)
             Or, idea: scale(factor, around = (point or line))
  * [Medium] RotateFromTo? And use in ScaleAxisFactor.to_scad instead of
             generator
  * [Medium] Scaling (XYZ and along a vector): specify the fixed point/offset
  * [Low]    mirror(along which axis and which point/offset)
  * [Low]    class MatrixTransform
  * [Low]    .to_matrix
  * [Low]    Merge .up(1).right(2) into a single Translate([2, 0, 1])? Dito for YPR.
  * [Low]    Clean up transform_generators.rotate, maybe use a generic dispatch mechanism
  * [Low]    IdentityTransform (for testing, we should probably have an empty SCAD object first)
  * [Low]    Scale: negative values should be translated to mirror for OpenSCAD
             (OpenSCAD does not allow negative scales), or do not allow negative
             scale factors

CSG:
  * [Medium] Make it so that a-(b+c) == a-b-c. Two options:
               * Difference always has a single subtrahend, which is an Object or a Union
                   * This is probably better
               * When subtracting a union, extract its children (must also be done for Object - Union)
  * [Low]    Can we make Union and Intersection independent of the order, so that a+b == b+a?
               * We could use a set instead of a list, or we could convert the list to a set for comparison. This would
                 require a hash method
               * We could manually compare the list elements, but that would be in O(n^2)

Scad:
  * [Low]    Remove union when implicit (e. g. in translate, or from the second one in difference)
  * [Low]    We should be able to compare SCAD objects independent of union/intersection order, so we can write unit
             tests for part/hole
  * [Low]    There should be an empty ScadObject that we can pass into and return from Object.to_scad; this would remove
             special case handling, e.g. RotateYpr.to_scad if target==None and ypr==(0, 0, 0)
  * [Low]    Remove null translates/scales/rotates (e. g. Plane(Z, 0))
  * [Medium] Ausgegebenen Code kommentieren (z. B. examples/plane)
  * [Low]    Render with SCAD function: rotate_from_to, Plane, Slice. This will make it possible to use symblic
             constants
  * [Low]    Modifiers: %background, #debug, !root, *disable
  * [Low]    Colors (RGBA)

Model:
  * [Low]    Name for transforms and objects - show in tree representation and as comment in SCAD code
  * [Low]    keep flag for transforms and CSG
               * Will not merge
  * [Low]    use_named flag for transforms and objects
               * Will not merge
               * Will write an SCAD module and be referenced by name
  * [Low]    SymbolicConstant for parametric SCAD files
               * Add symbol arithmetic classes
               * Allow in Matrix/Vector

Tests:
  * [Low]    Primitives (object and transform): test negative numbers

Documentation:
  * [Medium] Better readme file and project description
               * It's more of a CAD library that can render to SCAD than an SCAD
                 front-end
               * There are other libraries that do the same
               * Unique features: re-usable transforms, anchors, saves typing
  * [Medium] Translate takes a vector, but ScaleXyz and RotateXyz take single
             values. That's because it's not a vector. But you'll probably want
             to use the generator functions anyway.