Next:

Object:
  * [Medium] Assembly objects
             Idea: Assembly is an Object; Object has a render() that returns an object or a CSG; primitives' render()
             returns self
  * [Medium] larger, smaller
             Since we can't enlarge an assembly without rendering it first, we may need to defer enlarging to
             render-time by adding an Enlarge class.
  * [Medium] Anchors
             Idea:
                 wheel = Wheel(2).center.at(car.front_left_wheel)
  * [Medium] center flag (and use in examples where appropriate)
             Probably better: .center() which transforms to the center
             Probably even better: use the anchor mechanism
  * [Low]    Shape (2-dimensional object) and associated primitives
  * [Low]    Investigate part/hole
               * Are we supposed to do Pipe+Hole or Pipe-Hole?
               * Can we do Block - (Pipe +- Hole)?
               * Is Hole * Object defined?

Primitives:
  * [Medium] More primitives: cone
  * [Medium] More primitives? See OpenSCAD documentation
  * [Medium] Plane: through point

Transform:
  * [Medium] arrange objects in a grid (from list, or factory)
  * [Medium] Scale around (instead of along) axis?
             Maybe: scale(axis, along, around)
             Or, idea: scale(factor, around = (point or line))
             But we need the around parameter to specify a scale origin?
  * [Medium] Scaling (XYZ and along a vector): specify the fixed point/offset
  * [Medium] Inverse transforms
  * [Low]    mirror(along which axis and which point/offset)
  * [Low]    class MatrixTransform
  * [Low]    .to_matrix
  * [Low]    Merge .up(1).right(2) into a single Translate([2, 0, 1])? Dito for YPR.
  * [Low]    Clean up complex generators, maybe use a generic dispatch mechanism
  * [Low]    Scale: negative values should be translated to mirror for OpenSCAD
             (OpenSCAD does not allow negative scales), or do not allow negative
             scale factors

CSG:
  * [Medium] union generator without arguments
  * [Low]    Make it so that a-(b+c) == a-b-c. Two options:
               * Difference always has a single subtrahend, which is an Object or a Union
                   * This is probably better
               * When subtracting a union, extract its children (must also be done for Object - Union)
  * [Low]    Can we make Union and Intersection independent of the order, so that a+b == b+a?
               * We could use a set instead of a list, or we could convert the list to a set for comparison. This would
                 require a hash method
               * We could manually compare the list elements, but that would be in O(n^2)

Scad:
  * [Medium] Better comments for SCAD objects:
               * Show canonical form for generator or textual description ("Rotate from ... to ...")
                 instead of object representation
               * Simplify vectors (X, 2*X, -X, -2*X), and show as <x, y, z> otherwise
  * [Low]    Remove union when implicit (e. g. in translate, or from the second one in difference)
  * [Low]    We should be able to compare SCAD objects independent of union/intersection order, so we can write unit
             tests for part/hole
  * [Low]    There should be an empty ScadObject that we can pass into and return from Object.to_scad; this would remove
             special case handling, e.g. RotateYpr.to_scad if target==None and ypr==(0, 0, 0)
  * [Low]    Remove null translates/scales/rotates (e. g. Plane(Z, 0))
  * [Low]    Render with SCAD function: rotate_from_to, Plane, Slice. This will make it possible to use symblic
             constants
  * [Low]    Modifiers: %background, #debug, !root, *disable
  * [Low]    Colors (RGBA)

Model:
  * [Low]    Name for transforms and objects - show in tree representation and as comment in SCAD code
  * [Low]    keep flag for transforms and CSG
               * Will not merge
  * [Low]    use_named flag for transforms and objects
               * Will not merge
               * Will write an SCAD module and be referenced by name
  * [Low]    SymbolicConstant for parametric SCAD files
               * Add symbol arithmetic classes
               * Allow in Matrix/Vector

Tests:
  * [Low]    Primitives (object and transform): test negative numbers
  * [Low]    Pass empty or wrong-size vectors, must fail (transform primitives
             and object primitives)

Util:
  * [Low]    Matrix should probably accept lists (row-wise) and Vectors
             (column-wise), and then there should be more explicit from_rows and
             from_columns

General:
  * [Low]    __str__

Library:

Documentation:
  * [Medium] Better readme file and project description
               * It's more of a CAD library that can render to SCAD than an SCAD
                 front-end
               * There are other libraries that do the same
               * Unique features: re-usable transforms, anchors, saves typing
  * [Medium] Translate takes a vector, but ScaleXyz and RotateXyz take single
             values. That's because it's not a vector. But you'll probably want
             to use the generator functions anyway.
  * [Medium] Docstrings
